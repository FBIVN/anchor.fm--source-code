const HttpStatusError = require('./../errors').HttpStatusError;
const { AUDIO_TYPES } = require('./../audio/constants');

const REQUIRED_MS_BETWEEN_MUSIC_AND_ADS = 60000; // one minute
const REQUIRED_MS_OF_NON_MUSIC_BETWEEN_ADS = 600000; // ten minutes

const getInvalidPlacementsForOrderedAudioSet = (audiosInOrder, audioMetadataByAudioIds) => {
    const hasMusic = audiosInOrder.some(({ type }) => type === AUDIO_TYPES.MUSIC);
    const invalidAudiosByAudioIndex = {};

    if (!hasMusic) {
        return invalidAudiosByAudioIndex;
    }

    let durationIntoEpisode = 0;
    let durationIntoEpisodeExcludingMusic = 0;

    /*  { index: 1, durationIntoEpisode: 10, durationIntoEpisodeExcludingMusicAndAds: 10 }
     *  { index: 2, durationIntoEpisode: 80, durationIntoEpisodeExcludingMusicAndAds: 20 }
     *  etc
     */
    let mostRecentMusicTimestamp = null;
    let mostRecentAdTimestamp = null;

    audiosInOrder.forEach((audio, index) => {
        const { audioId, type, duration } = audio;
        const audioMetadata = audioMetadataByAudioIds[audioId] || {};

        if (audio.type === AUDIO_TYPES.AD || audioMetadata.isMarkedAsExternalAd) {
            // first check against most recent music using raw durations
            const invalidDueToMusic =
                mostRecentMusicTimestamp &&
                durationIntoEpisode - mostRecentMusicTimestamp.durationIntoEpisode < REQUIRED_MS_BETWEEN_MUSIC_AND_ADS;

            // now check against the most recent ad, excluding music time.
            // the other one needs to be marked invalid as well
            const invalidDueToOtherAd =
                mostRecentAdTimestamp &&
                durationIntoEpisodeExcludingMusic - mostRecentAdTimestamp.durationIntoEpisodeExcludingMusic <
                    REQUIRED_MS_OF_NON_MUSIC_BETWEEN_ADS;
            if (invalidDueToOtherAd && !invalidAudiosByAudioIndex[mostRecentAdTimestamp.index]) {
                invalidAudiosByAudioIndex[mostRecentAdTimestamp.index] = audiosInOrder[mostRecentAdTimestamp.index];
            }

            if (invalidDueToMusic || invalidDueToOtherAd) {
                invalidAudiosByAudioIndex[index] = audio;
            }

            if (audio.duration) {
                durationIntoEpisode += audio.duration;
                durationIntoEpisodeExcludingMusic += audio.duration;
            }

            mostRecentAdTimestamp = {
                index,
                durationIntoEpisode,
                durationIntoEpisodeExcludingMusic,
            };
            return;
        }

        if (audio.type === AUDIO_TYPES.MUSIC) {
            if (
                mostRecentAdTimestamp &&
                durationIntoEpisodeExcludingMusic - mostRecentAdTimestamp.durationIntoEpisodeExcludingMusic <
                    REQUIRED_MS_BETWEEN_MUSIC_AND_ADS &&
                !invalidAudiosByAudioIndex[mostRecentAdTimestamp.index]
            ) {
                invalidAudiosByAudioIndex[mostRecentAdTimestamp.index] = audiosInOrder[mostRecentAdTimestamp.index];
            }

            durationIntoEpisode += audioMetadata.thirdPartyDuration || duration;

            mostRecentMusicTimestamp = {
                index,
                durationIntoEpisode,
                durationIntoEpisodeExcludingMusic,
            };
            return;
        }

        durationIntoEpisode += duration;
        durationIntoEpisodeExcludingMusic += duration;
    });

    return invalidAudiosByAudioIndex;
};

module.exports = { getInvalidPlacementsForOrderedAudioSet };
